<!DOCTYPE html>
<html>
	<head>
		<title>WebRTC TURN Server Test</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				margin: 20px;
				background: #f5f5f5;
			}
			.container {
				max-width: 900px;
				margin: 0 auto;
				background: white;
				padding: 20px;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}
			.result {
				margin: 8px 0;
				padding: 12px;
				border-radius: 5px;
				font-family: "Courier New", monospace;
				font-size: 14px;
			}
			.success {
				background-color: #d4edda;
				color: #155724;
				border-left: 4px solid #28a745;
			}
			.error {
				background-color: #f8d7da;
				color: #721c24;
				border-left: 4px solid #dc3545;
			}
			.info {
				background-color: #d1ecf1;
				color: #0c5460;
				border-left: 4px solid #17a2b8;
			}
			.warning {
				background-color: #fff3cd;
				color: #856404;
				border-left: 4px solid #ffc107;
			}
			.candidate {
				background-color: #e7f3ff;
				color: #004085;
				border-left: 4px solid #007bff;
				font-size: 12px;
			}

			button {
				padding: 12px 24px;
				margin: 8px;
				background: #007bff;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
				transition: background 0.2s;
			}
			button:hover {
				background: #0056b3;
			}
			button:disabled {
				background: #6c757d;
				cursor: not-allowed;
			}

			.test-section {
				margin: 20px 0;
				padding: 15px;
				border: 1px solid #ddd;
				border-radius: 5px;
				background: #f8f9fa;
			}

			.results-container {
				max-height: 500px;
				overflow-y: auto;
				border: 1px solid #ddd;
				border-radius: 4px;
				padding: 10px;
				background: white;
			}

			.stats {
				display: inline-block;
				margin: 5px 10px;
				padding: 5px 10px;
				background: #e9ecef;
				border-radius: 3px;
				font-size: 12px;
			}

			h1 {
				color: #333;
				text-align: center;
			}
			h2 {
				color: #495057;
				margin-top: 0;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>üß™ WebRTC TURN Server Test</h1>

			<div class="test-section">
				<h2>Quick Tests</h2>
				<button onclick="testICEServers()">Test ICE Servers</button>
				<button onclick="testSTUN()">Test STUN Only</button>
				<button onclick="testTURN()">Test TURN Only</button>
				<button onclick="clearResults()">Clear Results</button>
			</div>

			<div class="test-section">
				<h2>Advanced Tests</h2>
				<button onclick="testDetailed()">Detailed Analysis</button>
				<button onclick="testConnectivity()">Connection Test</button>
				<button onclick="testMultipleServers()">Test All Servers</button>
			</div>

			<div class="results-container">
				<div id="results"></div>
			</div>
		</div>

		<script>
			let testInProgress = false;
			let candidateStats = { host: 0, srflx: 0, relay: 0, total: 0 };

			function log(message, type = "info") {
				const results = document.getElementById("results");
				const div = document.createElement("div");
				div.className = `result ${type}`;
				div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
				results.appendChild(div);
				results.scrollTop = results.scrollHeight;
			}

			function clearResults() {
				document.getElementById("results").innerHTML = "";
				candidateStats = { host: 0, srflx: 0, relay: 0, total: 0 };
			}

			function updateStats() {
				const statsHtml = `
                <span class="stats">Total: ${candidateStats.total}</span>
                <span class="stats">Host: ${candidateStats.host}</span>
                <span class="stats">STUN: ${candidateStats.srflx}</span>
                <span class="stats">TURN: ${candidateStats.relay}</span>
            `;
				log(`üìä Current Stats: ${statsHtml}`, "info");
			}

			async function testICEServers() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Testing ICE servers configuration...", "info");
				candidateStats = { host: 0, srflx: 0, relay: 0, total: 0 };

				const iceServers = [
					{ urls: "stun:localhost:3478" },
					{ urls: "turn:localhost:3478", username: "", credential: "" },
				];

				try {
					const pc = new RTCPeerConnection({ iceServers });

					pc.onicecandidate = (event) => {
						if (event.candidate) {
							candidateStats.total++;
							const candidate = event.candidate.candidate;

							if (candidate.includes("host")) {
								candidateStats.host++;
								log(`üè† Host candidate: ${candidate}`, "candidate");
							} else if (candidate.includes("srflx")) {
								candidateStats.srflx++;
								log(`üì° STUN candidate (srflx): ${candidate}`, "success");
							} else if (candidate.includes("relay")) {
								candidateStats.relay++;
								log(`üîÑ TURN candidate (relay): ${candidate}`, "success");
							} else {
								log(`‚ùì Other candidate: ${candidate}`, "info");
							}
						} else {
							log("‚úÖ ICE gathering complete!", "success");
							updateStats();

							if (candidateStats.srflx > 0 && candidateStats.relay > 0) {
								log(
									"üéâ Excellent! Both STUN and TURN servers are working!",
									"success"
								);
							} else if (candidateStats.srflx > 0) {
								log(
									"‚ö†Ô∏è STUN working, but no TURN relay candidates found",
									"warning"
								);
							} else if (candidateStats.relay > 0) {
								log(
									"‚ö†Ô∏è TURN working, but no STUN reflexive candidates found",
									"warning"
								);
							} else {
								log(
									"‚ùå No STUN or TURN candidates found - check server configuration",
									"error"
								);
							}
						}
					};

					pc.onicegatheringstatechange = () => {
						log(`ICE Gathering State: ${pc.iceGatheringState}`, "info");
					};

					pc.oniceconnectionstatechange = () => {
						log(`ICE Connection State: ${pc.iceConnectionState}`, "info");
					};

					// Create a data channel to trigger ICE gathering
					pc.createDataChannel("test");
					const offer = await pc.createOffer();
					await pc.setLocalDescription(offer);

					log("‚è≥ ICE gathering started... (waiting up to 5 seconds)", "info");

					setTimeout(() => {
						pc.close();
						log("üèÅ Test completed", "info");
						testInProgress = false;
					}, 5000);
				} catch (error) {
					log(`‚ùå Error: ${error.message}`, "error");
					testInProgress = false;
				}
			}

			async function testSTUN() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Testing STUN server specifically...", "info");
				log("üìç Server: stun:localhost:3478", "info");

				let stunCandidatesFound = 0;
				let hostCandidatesFound = 0;
				let totalCandidates = 0;

				try {
					const pc = new RTCPeerConnection({
						iceServers: [{ urls: "stun:localhost:3478" }],
					});

					pc.onicecandidate = (event) => {
						if (event.candidate) {
							totalCandidates++;
							const candidate = event.candidate.candidate;

							if (candidate.includes("srflx")) {
								stunCandidatesFound++;
								log(
									`‚úÖ STUN server working! Server reflexive candidate found:`,
									"success"
								);
								log(`üì° ${candidate}`, "candidate");
							} else if (candidate.includes("host")) {
								hostCandidatesFound++;
								log(`üè† Host candidate: ${candidate}`, "candidate");
							} else {
								log(`‚ùì Other candidate type: ${candidate}`, "info");
							}
						} else {
							log("üèÅ STUN test ICE gathering complete", "info");
							log(
								`üìä Results: ${totalCandidates} total candidates (${hostCandidatesFound} host, ${stunCandidatesFound} STUN)`,
								"info"
							);

							if (stunCandidatesFound > 0) {
								log("üéâ STUN server is working correctly!", "success");
							} else {
								log("‚ö†Ô∏è No STUN server reflexive candidates found", "warning");
								log(
									"üí° This might indicate STUN server is not accessible or not working",
									"warning"
								);
							}
						}
					};

					pc.onicegatheringstatechange = () => {
						log(
							`STUN Test - ICE Gathering State: ${pc.iceGatheringState}`,
							"info"
						);
					};

					pc.createDataChannel("stun-test");
					const offer = await pc.createOffer();
					await pc.setLocalDescription(offer);

					log("‚è≥ STUN test started... (waiting up to 4 seconds)", "info");

					setTimeout(() => {
						pc.close();
						log("üèÅ STUN test completed", "info");
						testInProgress = false;
					}, 4000);
				} catch (error) {
					log(`‚ùå STUN test error: ${error.message}`, "error");
					testInProgress = false;
				}
			}

			async function testTURN() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Testing TURN server specifically...", "info");
				log("üìç Server: turn:localhost:3478", "info");

				let turnCandidatesFound = 0;
				let hostCandidatesFound = 0;
				let totalCandidates = 0;

				try {
					const pc = new RTCPeerConnection({
						iceServers: [
							{
								urls: "turn:localhost:3478",
								username: "",
								credential: "",
							},
						],
					});

					pc.onicecandidate = (event) => {
						if (event.candidate) {
							totalCandidates++;
							const candidate = event.candidate.candidate;

							if (candidate.includes("relay")) {
								turnCandidatesFound++;
								log(
									"‚úÖ TURN server working! Relay candidate found:",
									"success"
								);
								log(`üîÑ ${candidate}`, "candidate");
							} else if (candidate.includes("host")) {
								hostCandidatesFound++;
								log(`üè† Host candidate: ${candidate}`, "candidate");
							} else if (candidate.includes("srflx")) {
								log(`üì° Server reflexive candidate: ${candidate}`, "candidate");
							} else {
								log(`‚ùì Other candidate type: ${candidate}`, "info");
							}
						} else {
							log("üèÅ TURN test ICE gathering complete", "info");
							log(
								`üìä Results: ${totalCandidates} total candidates (${hostCandidatesFound} host, ${turnCandidatesFound} TURN relay)`,
								"info"
							);

							if (turnCandidatesFound > 0) {
								log("üéâ TURN server is working correctly!", "success");
							} else {
								log("‚ö†Ô∏è No TURN relay candidates found", "warning");
								log(
									"üí° Check TURN server configuration and credentials",
									"warning"
								);
							}
						}
					};

					pc.onicegatheringstatechange = () => {
						log(
							`TURN Test - ICE Gathering State: ${pc.iceGatheringState}`,
							"info"
						);
					};

					pc.createDataChannel("turn-test");
					const offer = await pc.createOffer();
					await pc.setLocalDescription(offer);

					log("‚è≥ TURN test started... (waiting up to 4 seconds)", "info");

					setTimeout(() => {
						pc.close();
						log("üèÅ TURN test completed", "info");
						testInProgress = false;
					}, 4000);
				} catch (error) {
					log(`‚ùå TURN test error: ${error.message}`, "error");
					testInProgress = false;
				}
			}

			async function testDetailed() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Running detailed connectivity analysis...", "info");

				const servers = [
					{
						name: "STUN Only",
						config: { iceServers: [{ urls: "stun:localhost:3478" }] },
					},
					{
						name: "TURN Only",
						config: {
							iceServers: [
								{ urls: "turn:localhost:3478", username: "", credential: "" },
							],
						},
					},
					{
						name: "Both STUN & TURN",
						config: {
							iceServers: [
								{ urls: "stun:localhost:3478" },
								{ urls: "turn:localhost:3478", username: "", credential: "" },
							],
						},
					},
				];

				for (let i = 0; i < servers.length; i++) {
					const server = servers[i];
					log(`\n--- Testing Configuration: ${server.name} ---`, "info");

					try {
						const pc = new RTCPeerConnection(server.config);
						let candidateCount = 0;
						let types = { host: 0, srflx: 0, relay: 0 };

						await new Promise((resolve) => {
							pc.onicecandidate = (event) => {
								if (event.candidate) {
									candidateCount++;
									const candidate = event.candidate.candidate;

									if (candidate.includes("host")) types.host++;
									else if (candidate.includes("srflx")) types.srflx++;
									else if (candidate.includes("relay")) types.relay++;

									log(`${server.name}: ${candidate}`, "candidate");
								} else {
									log(
										`${server.name} complete: ${candidateCount} candidates (host:${types.host}, stun:${types.srflx}, turn:${types.relay})`,
										"info"
									);
									resolve();
								}
							};

							pc.createDataChannel("detailed-test");
							pc.createOffer().then((offer) => pc.setLocalDescription(offer));

							setTimeout(resolve, 3000);
						});

						pc.close();
					} catch (error) {
						log(`${server.name} failed: ${error.message}`, "error");
					}
				}

				log("üèÅ Detailed analysis completed", "info");
				testInProgress = false;
			}

			async function testConnectivity() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Testing connection establishment...", "info");

				try {
					const pc1 = new RTCPeerConnection({
						iceServers: [
							{ urls: "stun:localhost:3478" },
							{ urls: "turn:localhost:3478", username: "", credential: "" },
						],
					});

					const pc2 = new RTCPeerConnection({
						iceServers: [
							{ urls: "stun:localhost:3478" },
							{ urls: "turn:localhost:3478", username: "", credential: "" },
						],
					});

					pc1.oniceconnectionstatechange = () => {
						log(`PC1 ICE Connection: ${pc1.iceConnectionState}`, "info");
					};

					pc2.oniceconnectionstatechange = () => {
						log(`PC2 ICE Connection: ${pc2.iceConnectionState}`, "info");
					};

					// Create data channels
					const dc1 = pc1.createDataChannel("test");
					pc2.ondatachannel = (event) => {
						log("‚úÖ Data channel established!", "success");
					};

					// Exchange offers/answers
					const offer = await pc1.createOffer();
					await pc1.setLocalDescription(offer);
					await pc2.setRemoteDescription(offer);

					const answer = await pc2.createAnswer();
					await pc2.setLocalDescription(answer);
					await pc1.setRemoteDescription(answer);

					log(
						"‚è≥ Attempting peer connection... (waiting up to 10 seconds)",
						"info"
					);

					setTimeout(() => {
						log(
							`Final connection states: PC1=${pc1.iceConnectionState}, PC2=${pc2.iceConnectionState}`,
							"info"
						);
						pc1.close();
						pc2.close();
						log("üèÅ Connection test completed", "info");
						testInProgress = false;
					}, 10000);
				} catch (error) {
					log(`‚ùå Connection test error: ${error.message}`, "error");
					testInProgress = false;
				}
			}

			async function testMultipleServers() {
				if (testInProgress) return;
				testInProgress = true;

				log("üîç Testing multiple server configurations...", "info");

				const serverConfigs = [
					{ name: "Local STUN", urls: "stun:localhost:3478" },
					{
						name: "Local TURN",
						urls: "turn:localhost:3478",
						username: "",
						credential: "",
					},
					{ name: "Google STUN", urls: "stun:stun.l.google.com:19302" },
				];

				for (const server of serverConfigs) {
					log(`\n--- Testing: ${server.name} ---`, "info");

					try {
						const iceServer =
							server.username !== undefined
								? {
										urls: server.urls,
										username: server.username,
										credential: server.credential,
								  }
								: { urls: server.urls };

						const pc = new RTCPeerConnection({ iceServers: [iceServer] });
						let foundCandidate = false;

						await new Promise((resolve) => {
							pc.onicecandidate = (event) => {
								if (event.candidate) {
									foundCandidate = true;
									log(
										`${server.name}: ${event.candidate.candidate}`,
										"candidate"
									);
								} else {
									log(
										`${server.name}: ${
											foundCandidate ? "‚úÖ Working" : "‚ö†Ô∏è No candidates"
										}`,
										foundCandidate ? "success" : "warning"
									);
									resolve();
								}
							};

							pc.createDataChannel("multi-test");
							pc.createOffer().then((offer) => pc.setLocalDescription(offer));

							setTimeout(resolve, 3000);
						});

						pc.close();
					} catch (error) {
						log(`${server.name}: ‚ùå ${error.message}`, "error");
					}
				}

				log("üèÅ Multiple server test completed", "info");
				testInProgress = false;
			}

			// Auto-run basic info on page load
			window.onload = () => {
				log("üöÄ WebRTC TURN Test Page Loaded", "info");
				log(
					"üí° Click buttons above to test different aspects of the TURN server",
					"info"
				);
				log(
					"üîß Open browser dev tools (F12) for additional WebRTC debugging info",
					"info"
				);
				log(
					"üìç Testing servers: stun:localhost:3478 and turn:localhost:3478",
					"info"
				);
			};
		</script>
	</body>
</html>
